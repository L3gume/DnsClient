package com.dns;

import java.net.*;
import java.nio.ByteBuffer;
import java.util.ArrayList;

// TODO: make DnsMessage properly keep information stored in records
public class DnsMessage {
    private String domainName;
    private QueryType type;
    private short senderID;
    private boolean isQuestion;

    // Answer header
    private short ansID;
    private short ansQDCount;
    private short ansANCount;
    private short ansNSCount;
    private short ansARCount;
    private boolean ansAuthority;
    private boolean ansRecSupport;
    private byte ansRCode;
    // Answer body
    private String ansIPAddr;
    private String ansNameServer;
    private String ansAlias;
    private String ansDomain;
    private String ansExchange;
    private int ansPreference;
    private int ansTTL;
    private QueryType ansType;
    private short ansClass;
    private short ansRDLength;

    public DnsMessage(String domainName, QueryType type) {
        // domain name is too long, everything is going to break, exit now
        if (domainName.getBytes().length > 63) {
            System.err.println(String.format(
                    "Domain name: \"%s\" is longer that the allowed 63 octets (RFC 1034). Exiting...",
                    domainName));
            System.exit(127);
        }
        this.domainName = domainName;
        this.type = type;
        this.isQuestion = true;
    }

    public DnsMessage(ByteBuffer data, short senderID, int senderQueryLen) {
        this.isQuestion = false;
        this.senderID = senderID;

        parseHeader(data);
        // We need to ignore the query part
        data.position(data.position() + senderQueryLen);
        parseBody(data);
    }

    /**
     * builds the DNS query
     * @return a byte array ready to be sent
     */
    public int buildQuestion(ByteBuffer data, short ID) {
        this.senderID = ID;
        var len = buildHeader(data, ID);
        len += buildBody(data);
        return len ;
    }

    /**
     * returns a 16-byte DNS header
     * @param id the id of the sender, 16-bit integer
     * @return a 16-byte array representing the header
     */
    private int buildHeader(ByteBuffer data, short id) {
        // Header is the same for all types of DNS queries
        // Only thing that changes is the id, which will be generated by the derived class
        // we need 12 bytes to make the header
        // ID
        data.putShort(id);
        //bytes.add((byte)(id));
        // |QR(1)| Opcode(4) |AA(1)|TC(1)|RD(1)|
        data.put((byte)(0b00000001));
        // |RA(1)|   Z(3)   | RCODE(4) |
        data.put((byte)(0b10000000));
        // QDCOUNT, always equal to 1
        data.putShort((short)0x0001);
        // ANCOUNT, only matters in response
        data.putShort((short)0x0000);
        // NSCOUNT, can be ignored
        data.putShort((short)0x0000);
        // ARCOUNT, ????
        data.putShort((short)0x0000);
        return 0;
    }

    private void parseHeader(ByteBuffer data) {
        ansID = (short)(0xFFFF & data.getShort());
        assert ansID == senderID;
        var buf = data.get(); // get next byte
        // | QR | OpCode | AA | TC | RD |
        assert (buf & 0b10000000) == 0b10000000; // Make sure the message is a response
        ansAuthority = (buf & 0b00000100) == 0b00000100;
        buf = data.get(); // get next byte
        // | RA | Z | RCODE |
        var recSupported = (buf & 0b10000000) == 0b10000000;
        if (!recSupported) {
            System.err.println("ERROR\tThe DNS server does not support recursive queries.");
        }
        ansRCode = (byte)(buf & 0xF); // 4 lower bytes
        var errMsg = "";
        var errCode = 0;
        switch (ansRCode) {
            case 1:
                errMsg = "ERROR\tFormat error: name server could not interpret the query due to bad formatting.";
                errCode = 1;
                break;
            case 2:
                errMsg = "ERROR\tServer failure: internal problem in the server made it unable to process the query.";
                errCode = 2;
                break;
            case 3:
                errMsg = "NOTFOUND";
                errCode = 3;
                break;
            case 4:
                errMsg = "ERROR\tNot implemented: the server does not support this type of query.";
                errCode = 4;
                break;
            case 5:
                errMsg = "ERROR\tRefused: the name server refused to perform the query.";
                errCode = 5;
                break;
        }
        if (errCode != 0) {
            // handle error
            System.err.println(errMsg);
            System.exit(errCode);
        }
        ansQDCount = data.getShort();
        ansANCount = data.getShort();
        ansNSCount = data.getShort();
        ansARCount = data.getShort();
        // 12 bytes, header is done
    }

    private int buildBody(ByteBuffer data) {
        var len = 0;
        // the domain name was already checked
        len += parseDomainName(data);
        // type of query QTYPE
        switch (type) {
            case QUERY_A: data.putShort((short)0x0001); break;
            case QUERY_NS: data.putShort((short)0x0002); break;
            case QUERY_MX: data.putShort((short)0x000f); break;
            default:
                System.err.println("ERROR\tInvalid query type. Exiting...");
                System.exit(127);
        }
        // QCLASS, internet address
        data.putShort((short)0x0001);
        // done building the body
        return len + 4;
    }

    private void parseBody(ByteBuffer data) {
        System.out.println(String.format("\n***Answer Section (%d records)***\n", ansANCount));
        for (var i = 0; i < ansANCount; ++i) {
            parseRecord(data);
        }
        System.out.println(String.format("\n***Additional Section (%d records)***\n", ansARCount));
        for (var i = 0; i < ansARCount; ++i) {
            parseRecord(data);
        }
    }

    private void parseRecord(ByteBuffer data) {
        ansDomain = parseLabels(data);
        ansType = parseResponseType(data);
        ansClass = data.getShort();
        if (ansClass != 1) {
            System.err.format("ERROR\tUnexpected response class: %d. Should be internet address (1).", ansClass);
            System.exit(127);
        }
        ansTTL = data.getInt();
        ansRDLength = data.getShort();
        switch (ansType) {
            case QUERY_A:
                parseIP(data);
                break;
            case QUERY_NS:
                parseNameServer(data);
                break;
            case QUERY_MX:
                parseMailServer(data);
                break;
            case QUERY_CNAME:
                parseAlias(data);
                break;
        }
    }

    private QueryType parseResponseType(ByteBuffer data) {
        var type = data.getShort();
        switch (type) {
            case 0x0001: return QueryType.QUERY_A;
            case 0x0002: return QueryType.QUERY_NS;
            case 0x0005: return QueryType.QUERY_CNAME;
            case 0x000F: return QueryType.QUERY_MX;
        }
        return QueryType.QUERY_A;
    }

    private String parseLabels(ByteBuffer data) {
        byte labelLen, buf;
        var strBuild = new StringBuilder();
        while (true) {
            labelLen = data.get();
            if (labelLen == 0) break; // null terminator

            if ((labelLen & 0b11000000) == 0b11000000) {
                // this is a pointer, back up and get short instead
                data.position(data.position() - 1);
                var thing = data.getShort();
                var ptr =  thing & 0x3FFF; // ignore 2 uppermost bits
                var pos = data.position(); // keep position for after we're done
                data.position(ptr); // jump to offset
                strBuild.append(parseLabels(data)); // parse
                data.position(pos); // reset position
                return strBuild.toString();
            }
            for (var i = 0; i < labelLen; ++i) {
                buf = data.get();
                if (buf == 0) {
                    System.err.format(
                            "ERROR\tUnexpected null termination while parsing label: %s\n",
                            strBuild.toString());
                    return "unparsed label";
                }
                strBuild.append((char)buf);
            }
            strBuild.append('.');
        }
        var str = strBuild.toString();
        if (str.length() > 0) {
            return str.substring(0, str.length() - 1);
        } else {
            return "";
        }
    }

    private void parseIP(ByteBuffer data) {
        assert ansRDLength == 4;
        var strBuild = new StringBuilder();
        for (var i = 0; i < 3; ++i) {
            strBuild.append(data.get() & 0xFF).append('.');
        }
        strBuild.append(data.get() & 0xFF);
        ansIPAddr= strBuild.toString();
        System.out.println(String.format("IP\t%s\t%d\t%s", ansIPAddr, ansTTL, ansAuthority ? "auth" : "noauth"));
    }

    private void parseNameServer(ByteBuffer data) {
        ansNameServer = parseLabels(data);
        System.out.println(String.format("NS\t%s\t%d\t%s", ansNameServer, ansTTL, ansAuthority ? "auth" : "noauth"));
    }

    private void parseAlias(ByteBuffer data) {
        ansAlias = parseLabels(data);
        System.out.println(String.format("CNAME\t%s\t%d\t%s", ansAlias, ansTTL, ansAuthority ? "auth" : "noauth"));
        }

    private void parseMailServer(ByteBuffer data) {
        ansPreference = (int)data.getShort();
        ansExchange = parseLabels(data);
        System.out.println(String.format("MX\t%s\t%d\t%d\t%s", ansExchange, ansPreference, ansTTL, ansAuthority ? "auth" : "noauth"));
    }

    private int parseDomainName(ByteBuffer data) {
        var len = 0;
        var split = domainName.split("\\.");
        for (var label : split) {
            data.put((byte)label.length());
            len++; // size of label: 1 byte
            for (var ch : label.toCharArray()) {
                data.put((byte)ch);
                len++; // 1 character
            }
        }
        data.put((byte)0x00);
        return ++len;
    }

}
