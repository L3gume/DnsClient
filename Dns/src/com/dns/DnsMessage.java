package com.dns;

import java.net.*;
import java.nio.ByteBuffer;
import java.util.ArrayList;

// TODO: build ways to extract info from data when the DnsMessage is a response
public class DnsMessage {
    private String domainName;
    private QueryType type;
    private short senderID;
    private boolean isQuestion;

    // Answer header
    private short ansID;
    private short ansQDCount;
    private short ansANCount;
    private short ansNSCount;
    private short ansARCount;
    private boolean ansAuthority;
    private boolean ansRecSupport;
    private byte ansRCode;
    // Answer body
    private ArrayList<String> ansIPAddr;
    private ArrayList<String> ansNameServer;
    private ArrayList<String> ansAlias;
    private ArrayList<String> ansDomain;
    private ArrayList<String> ansExchange;
    private ArrayList<Integer> ansPreference;
    private QueryType ansType;
    private short ansClass;
    private int ansTTL;
    private short ansRDLength;

    public DnsMessage(String domainName, QueryType type) {
        // domain name is too long, everything is going to break, exit now
        if (domainName.getBytes().length > 63) {
            System.err.println(String.format(
                    "Domain name: \"%s\" is longer that the allowed 63 octets (RFC 1034). Exiting...",
                    domainName));
            System.exit(127);
        }
        ansIPAddr = new ArrayList<>();
        ansNameServer = new ArrayList<>();
        ansAlias = new ArrayList<>();
        ansDomain = new ArrayList<>();
        ansExchange = new ArrayList<>();
        ansPreference = new ArrayList<>();
        this.domainName = domainName;
        this.type = type;
        this.isQuestion = true;
    }

    public DnsMessage(ByteBuffer data, short senderID, int senderQueryLen) {
        this.isQuestion = false;
        this.senderID = senderID;

        ansIPAddr = new ArrayList<>();
        ansNameServer = new ArrayList<>();
        ansAlias = new ArrayList<>();
        ansDomain = new ArrayList<>();
        ansExchange = new ArrayList<>();
        ansPreference = new ArrayList<>();

        // TODO: populate other fields and make util functions to fetch info
        parseHeader(data);
        System.out.println(getHeaderString());
        // We need to ignore the query part
        data.position(data.position() + senderQueryLen);
        parseBody(data);
    }

    /**
     * builds the DNS query
     * @return a byte array ready to be sent
     */
    public int buildQuestion(ByteBuffer data, short ID) {
        this.senderID = ID;
        var len = buildHeader(data, ID);
        len += buildBody(data);
        return len ;
    }

    /**
     * checks if the message is a question
     * @return true if it's a question
     */
    public boolean isQuestion() {
        return isQuestion;
    }

    /**
     * checks if the message is a response
     * @return true if it's a response
     */
    public boolean isResponse() {
        return !isQuestion;
    }

    public String getHeaderString() {
        return String.format(
                "\n------ HEADER ------\nID: %x\nQDCOUNT: %d\nANCOUNT: %d\nNSCOUNT: %d\nARCOUNT: %d\n",
                ansID,
                ansQDCount,
                ansANCount,
                ansNSCount,
                ansARCount);
    }

    public String getResponseString() {
        if (isQuestion) {
            System.err.println("ERROR - Cannot output response string: message is a question.");
            return "";
        }
        var auth = ansAuthority ? "auth" : "noauth";
        var strBuild = new StringBuilder();
        for (var ip : ansIPAddr) {
            strBuild.append(String.format("IP - %s - %d - %s\n", ip, ansTTL, auth));
        }
        for (var ns : ansNameServer) {
            strBuild.append(String.format("NS - %s - %d - %s\n", ns, ansTTL, auth));
        }
        for (var al : ansAlias) {
            strBuild.append(String.format("CNAME - %s - %d - %s\n", al, ansTTL, auth));
        }
        for (var i = 0; i < ansExchange.size(); ++i) {
            strBuild.append(String.format("MX - %s - %d - %d - %s\n", ansExchange.get(i), ansPreference.get(i), ansTTL, auth));
        }
        return strBuild.toString();
    }

    /**
     * returns a 16-byte DNS header
     * @param id the id of the sender, 16-bit integer
     * @return a 16-byte array representing the header
     */
    private int buildHeader(ByteBuffer data, short id) {
        // Header is the same for all types of DNS queries
        // Only thing that changes is the id, which will be generated by the derived class
        // we need 12 bytes to make the header
        // ID
        data.putShort(id);
        //bytes.add((byte)(id));
        // |QR(1)| Opcode(4) |AA(1)|TC(1)|RD(1)|
        data.put((byte)(0b00000001));
        // |RA(1)|   Z(3)   | RCODE(4) |
        data.put((byte)(0b10000000));
        // QDCOUNT, always equal to 1
        data.putShort((short)0x0001);
        // ANCOUNT, only matters in response
        data.putShort((short)0x0000);
        // NSCOUNT, can be ignored
        data.putShort((short)0x0000);
        // ARCOUNT, ????
        data.putShort((short)0x0000);
        return 0;
    }

    private void parseHeader(ByteBuffer data) {
        ansID = (short)(0xFFFF & data.getShort());
        assert ansID == senderID;
        var buf = data.get(); // get next byte
        // | QR | OpCode | AA | TC | RD |
        assert (buf & 0b10000000) == 0b10000000; // Make sure the message is a response
        ansAuthority = (buf & 0b00000100) == 0b00000100;
        buf = data.get(); // get next byte
        // | RA | Z | RCODE |
        var recSupported = (buf & 0b10000000) == 0b10000000;
        if (!recSupported) {
            System.err.println("ERROR - The DNS server does not support recursive queries.");
        }
        ansRCode = (byte)(buf & 0xF); // 4 lower bytes
        var errMsg = "";
        var errCode = 0;
        switch (ansRCode) {
            case 1:
                errMsg = "ERROR - Format error: name server could not interpret the query due to bad formatting.";
                errCode = 1;
                break;
            case 2:
                errMsg = "ERROR - Server failure: internal problem in the server made it unable to process the query.";
                errCode = 2;
                break;
            case 3:
                errMsg = ansAuthority ? "ERROR - Name error: the queried domain name does not exist."
                        : "ERROR - Not found: the queried domain could not be found.";
                errCode = 3;
                break;
            case 4:
                errMsg = "ERROR - Not implemented: the server does not support this type of query.";
                errCode = 4;
                break;
            case 5:
                errMsg = "ERROR - Refused: the name server refused to perform the query.";
                errCode = 5;
                break;
        }
        if (errCode != 0) {
            // handle error
            System.err.println(errMsg);
            System.exit(errCode);
        }
        ansQDCount = data.getShort();
        ansANCount = data.getShort();
        ansNSCount = data.getShort();
        ansARCount = data.getShort();
        // 12 bytes, header is done
    }

    private int buildBody(ByteBuffer data) {
        var len = 0;
        // the domain name was already checked
        len += parseDomainName(data);
        // type of query QTYPE
        switch (type) {
            case QUERY_A: data.putShort((short)0x0001); break;
            case QUERY_NS: data.putShort((short)0x0002); break;
            case QUERY_MX: data.putShort((short)0x000f); break;
            default:
                System.err.println("Invalid query type. Exiting...");
                System.exit(127);
        }
        // QCLASS, internet address
        data.putShort((short)0x0001);
        // done building the body
        return len + 4;
    }

    private void parseBody(ByteBuffer data) {
        // TODO: handle multiple responses
        for (var i = 0; i < ansANCount; ++i) {
            ansDomain.add(parseLabels(data));
            ansType = parseResponseType(data);
            ansClass = data.getShort();
            if (ansClass != 1) {
                System.err.format("ERROR - Unexpected response class: %d. Should be internet address (1).", ansClass);
                System.exit(127);
            }
            ansTTL = data.getInt();
            ansRDLength = data.getShort();
            switch (ansType) {
                case QUERY_A:
                    parseIP(data);
                    break;
                case QUERY_NS:
                    parseNameServer(data);
                    break;
                case QUERY_MX:
                    parseMailServer(data);
                    break;
                case QUERY_CNAME:
                    parseAlias(data);
                    break;
            }
        }
    }

    private QueryType parseResponseType(ByteBuffer data) {
        var type = data.getShort();
        switch (type) {
            case 0x0001: return QueryType.QUERY_A;
            case 0x0002: return QueryType.QUERY_NS;
            case 0x0005: return QueryType.QUERY_CNAME;
            case 0x000F: return QueryType.QUERY_MX;
        }
        return QueryType.QUERY_A;
    }

    private String parseLabels(ByteBuffer data) {
        byte labelLen, buf;
        var strBuild = new StringBuilder();
        while (true) {
            labelLen = data.get();
            if (labelLen == 0) break; // null terminator

            if ((labelLen & 0b11000000) == 0b11000000) {
                // this is a pointer, back up and get short instead
                data.position(data.position() - 1);
                var thing = data.getShort();
                var ptr =  thing & 0x3FFF; // ignore 2 uppermost bits
                var pos = data.position(); // keep position for after we're done
                data.position(ptr); // jump to offset
                strBuild.append(parseLabels(data)); // parse
                data.position(pos); // reset position
                return strBuild.toString();
            }
            for (var i = 0; i < labelLen; ++i) {
                buf = data.get();
                if (buf == 0) {
                    System.err.format(
                            "ERROR - Unexpected null termination while parsing label: %s\n",
                            strBuild.toString());
                }
                strBuild.append((char)buf);
            }
            strBuild.append('.');
        }
        var str = strBuild.toString();
        if (str.length() > 0) {
            return str.substring(0, str.length() - 1);
        } else {
            return "";
        }
    }

    private void parseIP(ByteBuffer data) {
        assert ansRDLength == 4;
        var strBuild = new StringBuilder();
        for (var i = 0; i < 3; ++i) {
            strBuild.append(data.get() & 0xFF).append('.');
        }
        strBuild.append(data.get() & 0xFF);
        ansIPAddr.add(strBuild.toString());
    }

    private void parseNameServer(ByteBuffer data) {
        ansNameServer.add(parseLabels(data));
    }

    private void parseAlias(ByteBuffer data) {
        ansAlias.add(parseLabels(data));
    }

    private void parseMailServer(ByteBuffer data) {
        ansPreference.add((int)data.getShort());
        ansExchange.add(parseLabels(data));
    }

    private int parseDomainName(ByteBuffer data) {
        var len = 0;
        var split = domainName.split("\\.");
        for (var label : split) {
            data.put((byte)label.length());
            len++; // size of label: 1 byte
            for (var ch : label.toCharArray()) {
                data.put((byte)ch);
                len++; // 1 character
            }
        }
        data.put((byte)0x00);
        return ++len;
    }

}
