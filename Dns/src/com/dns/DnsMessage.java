package com.dns;

import java.net.*;
import java.util.ArrayList;

// TODO: build ways to extract info from data when the DnsMessage is a response
public class DnsMessage {
    private String domainName;
    private QueryType type;
    private ArrayList<Byte> data;

    public DnsMessage(String domainName, QueryType type) {
        // domain name is too long, everything is going to break, exit now
        if (domainName.getBytes().length > 63) {
            System.err.println(String.format(
                    "Domain name: \"%s\" is longer that the allowed 63 octets (RFC 1034). Exiting...",
                    domainName));
            System.exit(1);
        }
        this.domainName = domainName;
        this.type = type;
        this.data = new ArrayList<>();
    }

    /**
     * builds the DNS query
     * @return a byte array ready to be sent
     */
    public byte[] buildQuestion(short ID) {
        assert isQuestion();
        data.clear();
        data.addAll(buildHeader(ID));
        data.addAll(buildBody());
        return null;
    }

    /**
     * checks if the message is a question
     * @return true if it's a question
     */
    public boolean isQuestion() {
        if (data.size() == 0) {
            return true;
        } else {
            return data.get(2) >> 7 == 0;
        }
    }

    /**
     * checks if the message is a response
     * @return true if it's a response
     */
    public boolean isResponse() {
        return !isQuestion();
    }

    /**
     * returns a 16-byte DNS header
     * @param id the id of the sender, 16-bit integer
     * @return a 16-byte array representing the header
     */
    private ArrayList<Byte> buildHeader(short id) {
        // Header is the same for all types of DNS queries
        // Only thing that changes is the id, which will be generated by the derived class
        // we need 12 bytes to make the header
        var bytes = new ArrayList<Byte>();
        // ID
        bytes.add((byte)(id >> 8));
        bytes.add((byte)(id));
        // |QR(1)| Opcode(4) |AA(1)|TC(1)|RD(1)|
        bytes.add((byte)(0b10000001));
        // |RA(1)|   Z(3)   | RCODE(4) |
        bytes.add((byte)(0b10000000));
        // QDCOUNT, always equal to 1
        bytes.add((byte)(0b00000000));
        bytes.add((byte)(0b00000001));
        // ANCOUNT, only matters in response
        bytes.add((byte)(0b00000000));
        bytes.add((byte)(0b00000000));
        // NSCOUNT, can be ignored
        bytes.add((byte)(0b00000000));
        bytes.add((byte)(0b00000000));
        // ARCOUNT, ????
        bytes.add((byte)(0b00000000));
        bytes.add((byte)(0b00000000));
        return bytes;
    }

    private ArrayList<Byte> buildBody() {
        var bytes = new ArrayList<Byte>();
        // the domain name was already checked
        bytes.addAll(parseDomainName());
        // type of query QTYPE
        bytes.add((byte)0x00);
        byte b = 0x00;
        switch (type) {
            case QUERY_A: b = (byte)(0x01); break;
            case QUERY_NS: b = (byte)(0x02); break;
            case QUERY_MX: b = (byte)(0x0f); break;
            default:
                System.err.println("Invalid query type. Exiting...");
                System.exit(1);
        }
        bytes.add(b);
        // QCLASS, internet address
        bytes.add((byte)0x00);
        bytes.add((byte)0x01);
        // done building the body
        return bytes;
    }

    private ArrayList<Byte> parseDomainName() {
        var parsed = new ArrayList<Byte>();
        var split = domainName.split(".");
        for (var label : split) {
            parsed.add((byte)label.length());
            for (var ch : label.getBytes()) {
                parsed.add(ch); // Apparently addAll doesn't work with type[]
            }
        }
        parsed.add((byte)0x00);
        return parsed;
    }

}
